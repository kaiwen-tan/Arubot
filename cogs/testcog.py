import discord
from datetime import date
import time
from discord.ext import commands
import random
import json


class test1(commands.Cog):

    def __init__(self, client):
        self.client = client

    @commands.Cog.listener()
    async def on_ready(self):

        dictionary = {
            "quote": "TEST_FIRST",
            "date": date.today().strftime("%B %d, %Y"),
            "time": time.strftime("%H:%M", time.localtime()),
            "quoted_by": "kevin"
        }

        # Serializing json
        json_object = json.dumps(dictionary, indent=4)
        with open("quote_data.json", "w") as outfile:
            outfile.write(json_object)

        await self.client.change_presence(status=discord.Status.online,
                                          activity=discord.Game('prefix: ?'))
        print("Arubot Online, ready!")

    @commands.command()
    async def ping(self, ctx):
        await ctx.send(f'your ping is {self.client.latency * 1000}')

    @commands.command()
    async def functions(self, ctx):
        all_commands = ['?quote', '?ping', '?8ball', '?randquote', '?purge',
                        'help']
        for i in all_commands:
            await ctx.send(i)

    @commands.command(aliases=['r'])
    async def roll(self, ctx, *, i):
        j = i.split('d')
        if '' in j:
            second = int(j[1])
            await ctx.send(
                f'your single dice roll is: '
                f'{random.randint(1, second)} \n '
                f'this dice is a D{second} \n '
                f'Generated by: **{ctx.author.display_name}**')
        else:
            try:
                first = int(j[0])
                second = int(j[1])
                if first > 100 or second > 1000:
                    await ctx.send('too big, I cannot handle this much math :(')
                elif len(j) > 1:
                    lst_rolls = []
                    for k in range(first):
                        lst_rolls.append(random.randint(1, second))
                    out = sum(lst_rolls)
                    await ctx.send(
                        f'your roll is: {out} \n '
                        f'These are the rolls: {lst_rolls} \n '
                        f'Generated by: **{ctx.author.display_name}**')
            except ValueError or IndexError:
                # try:
                #     second = int(j[1])
                #     await ctx.send(
                #         f'your single dice roll is: '
                #         f'{random.randint(1, second)} \n '
                #         f'this dice is a D{second} \n '
                #         f'Generated by: **{ctx.author.display_name}**')
                # except ValueError or IndexError:
                await ctx.send('invalid input or form, not a positive integer,'
                               ' form: xdy | for '
                               'x and y are any positive integers')

        # try:
        #     first = int(j[0])
        #     if len(j) > 1:
        #         second = int(j[1])
        #         lst_rolls = []
        #         for k in range(first):
        #             lst_rolls.append(random.randint(1, second))
        #         out = sum(lst_rolls)
        #         await ctx.send(
        #             f'your roll is: {out} \n '
        #             f'These are the rolls: {lst_rolls} \n '
        #             f'Generated by: **{ctx.author.display_name}**')
        #     else:
        #         second = int(j[1])
        #         await ctx.send(
        #             f'your single dice roll is: '
        #             f'{random.randint(1, second)} \n '
        #             f'this dice is a D{second} \n '
        #             f'Generated by: **{ctx.author.display_name}**')

                # if j[0] > 0 and j[1] > 0:
                #     if j[1] == 2:
                #         lst = ['Heads!', 'Tails!']
                #         await ctx.send(f'The coin\'s out come was: '
                #                        f'{random.choice(lst)} \n'
                #                        f'Or if you prefer: {random.randint(1, 2)} \n'
                #                        f'Generated by: **{ctx.author.display_name}**')
                #     else:
                #         await ctx.send(
                #             f'your roll is: {random.randint(1, j)} \n '
                #             f'this is dice is a D{j} \n '
                #             f'Generated by: **{ctx.author.display_name}**')
                # else:
                #     await ctx.send('invalid input, not a positive integer')
            # else:
            #
            #     await ctx.send(
            #         f'your single dice roll is: '
            #         f'{random.randint(1, second)} \n '
            #         f'this is dice is a D{second} \n '
            #         f'Generated by: **{ctx.author.display_name}**')
            #     # await ctx.send('invalid input or form, not a positive integer,'
            #     #                ' form: xdy | for'
            #     #                'x and y are any positive integers')








        # except IndexError:
        #     await ctx.send('invalid input or form, not a positive integer,'
        #                    ' form: xdy | for'
        #                    'x and y are any positive integers')


def setup(client):
    client.add_cog(test1(client))
